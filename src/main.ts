/*
 * Wasender TypeScript SDK - Lightweight helper for https://www.wasenderapi.com
 * Author: Shreshth Arora (scaffold generated by AI assistant)
 * Version: 0.1.0 (Integrated webhook handling)
 */

import {
  WasenderMessagePayload, // Discriminated union
  TextOnlyMessage, ImageUrlMessage, VideoUrlMessage, DocumentUrlMessage, AudioUrlMessage, StickerUrlMessage, ContactCardMessage, LocationPinMessage, // Specific payload types for existing methods
  WasenderSuccessResponse,
  RateLimitInfo,
  WasenderSendResult
} from "./messages";

import {
  WasenderAPIError,
  WasenderErrorResponse,
  WasenderAPIRawResponse
} from "./errors";

import {
    WEBHOOK_SIGNATURE_HEADER,
    verifyWasenderWebhookSignature,
    WasenderWebhookEvent
} from "./webhook";

import {
  GetAllContactsResult,
  GetContactInfoResult,
  GetContactProfilePictureResult,
  ContactActionResult,
  GetAllContactsResponse,
  GetContactInfoResponse,
  GetContactProfilePictureResponse,
  ContactActionResponse
} from "./contacts"; // Added imports for contact types
import {
  GetAllGroupsResult,
  GetGroupMetadataResult,
  GetGroupParticipantsResult,
  ModifyGroupParticipantsResult,
  UpdateGroupSettingsResult,
  GetAllGroupsResponse,
  GetGroupMetadataResponse,
  GetGroupParticipantsResponse,
  ModifyGroupParticipantsResponse,
  ModifyGroupParticipantsPayload,
  UpdateGroupSettingsPayload,
  UpdateGroupSettingsResponse
} from "./groups"; // Added imports for group types
import {
  WhatsAppSession, // Keep if used directly, otherwise covered by result types
  CreateWhatsAppSessionPayload,
  UpdateWhatsAppSessionPayload,
  ConnectSessionPayload,
  GetAllWhatsAppSessionsResult,
  GetWhatsAppSessionDetailsResult,
  CreateWhatsAppSessionResult,
  UpdateWhatsAppSessionResult,
  DeleteWhatsAppSessionResult,
  ConnectSessionResult,
  GetQRCodeResult,
  DisconnectSessionResult,
  RegenerateApiKeyResult,
  GetSessionStatusResult, // Assuming it might return RateLimitInfo
  GetAllWhatsAppSessionsResponse,
  GetWhatsAppSessionDetailsResponse,
  CreateWhatsAppSessionResponse,
  UpdateWhatsAppSessionResponse,
  DeleteWhatsAppSessionResponse,
  ConnectSessionResponse,
  GetQRCodeResponse,
  DisconnectSessionResponse,
  RegenerateApiKeyResponse,
  GetSessionStatusResponse
} from "./sessions"; // Added imports for session types

const SDK_VERSION = "0.1.0";

// Type for the fetch function to allow injection
export type FetchImplementation = (
  input: RequestInfo | URL,
  init?: RequestInit
) => Promise<globalThis.Response>;

export interface RetryConfig {
  /** Maximum number of retries for rate limit errors (HTTP 429). Defaults to 0 (no retries). */
  maxRetries?: number;
  /** Whether to enable retries on HTTP 429. Defaults to false. */
  enabled?: boolean;
}

/**
 * Interface for abstracting the necessary parts of an incoming HTTP request
 * for webhook processing. Adapt your framework's request object to this.
 */
export interface WebhookRequestAdapter {
  /** Function to get a header value by its name (case-insensitive). */
  getHeader: (name: string) => string | undefined | null;
  /** Function that returns the raw request body as a string. */
  getRawBody: () => Promise<string> | string;
}

// ---------- Core SDK Class ----------

export class Wasender {
  private readonly baseUrl: string;
  private readonly apiKey: string;
  private readonly fetchImpl: FetchImplementation;
  private readonly retryConfig: Required<RetryConfig>;
  private readonly configuredWebhookSecret?: string;

  constructor(
    apiKey: string, 
    baseUrl: string = "https://www.wasenderapi.com/api", 
    fetchImplementation?: FetchImplementation,
    retryOptions?: RetryConfig,
    webhookSecret?: string
  ) {
    if (!apiKey) {
      throw new Error("WASENDER_API_KEY is required to initialize the Wasender SDK.");
    }
    this.apiKey = apiKey;
    this.baseUrl = baseUrl.replace(/\/$/, ""); // Ensure no trailing slash
    this.fetchImpl = fetchImplementation || globalThis.fetch;
    this.retryConfig = {
        enabled: retryOptions?.enabled ?? false,
        maxRetries: retryOptions?.maxRetries ?? 0,
    };
    this.configuredWebhookSecret = webhookSecret;

    if (!this.fetchImpl) {
        throw new Error("Fetch implementation is not available. Please provide one (e.g., for Node.js < 18 by polyfilling globalThis.fetch or passing a custom fetch)." );
    }
  }

  private parseRateLimitHeaders(headers: Headers): RateLimitInfo {
    const limit = headers.get("X-RateLimit-Limit");
    const remaining = headers.get("X-RateLimit-Remaining");
    const reset = headers.get("X-RateLimit-Reset"); // Unix timestamp in seconds

    const resetTimestampNum = reset ? parseInt(reset, 10) : null;

    return {
      limit: limit ? parseInt(limit, 10) : null,
      remaining: remaining ? parseInt(remaining, 10) : null,
      resetTimestamp: resetTimestampNum,
      getResetTimestampAsDate: () => resetTimestampNum ? new Date(resetTimestampNum * 1000) : null,
    };
  }

  // General purpose request helper
  private async request<TResponse extends WasenderSuccessResponse | GetSessionStatusResponse | RegenerateApiKeyResponse >(
    method: "GET" | "POST" | "PUT" | "DELETE",
    path: string,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    body?: Record<string, any> | null
  ): Promise<{ response: TResponse; rateLimit: RateLimitInfo }> {
    const url = `${this.baseUrl}${path}`;
    const requestHeaders: HeadersInit = {
      "Authorization": `Bearer ${this.apiKey}`,
      "Accept": "application/json",
      "User-Agent": `wasender-typescript-sdk/${SDK_VERSION}`
    };

    let processedBody = body ? { ...body } : null;

    // Runtime casting for LocationPinMessage latitude/longitude if they are strings
    if (processedBody && typeof processedBody === 'object' && 'messageType' in processedBody && processedBody.messageType === 'location') {
      const locationPayload = (processedBody as any).location;
      if (locationPayload && typeof locationPayload.latitude === 'string') {
        locationPayload.latitude = parseFloat(locationPayload.latitude);
      }
      if (locationPayload && typeof locationPayload.longitude === 'string') {
        locationPayload.longitude = parseFloat(locationPayload.longitude);
      }
    }

    const requestOptions: RequestInit = {
      method,
      headers: requestHeaders,
    };

    if ((method === "POST" || method === "PUT") && processedBody) {
      requestHeaders["Content-Type"] = "application/json";
      requestOptions.body = JSON.stringify(processedBody);
    } else if (method === "POST" || method === "PUT") { // Body is null or not provided but method requires a body
        requestHeaders["Content-Type"] = "application/json";
        requestOptions.body = JSON.stringify({}); 
    } else if (method === "DELETE") {
      // No specific body handling for DELETE based on current API structure
    }

    let attempts = 0;
    // eslint-disable-next-line no-constant-condition
    while (true) {
      attempts++;
      let httpResponse: globalThis.Response;
      let rateLimitInfo: RateLimitInfo | undefined;

      try {
        httpResponse = await this.fetchImpl(url, requestOptions);
        rateLimitInfo = this.parseRateLimitHeaders(httpResponse.headers);
      } catch (networkError) {
        const errorToThrow =
          networkError instanceof Error
            ? new WasenderAPIError(
                `Network error: ${networkError.message}`,
                undefined, undefined, undefined, rateLimitInfo
              )
            : new WasenderAPIError(
                "An unknown network error occurred during the request.",
                undefined, undefined, undefined, rateLimitInfo
              );

        if (attempts > this.retryConfig.maxRetries || !this.retryConfig.enabled) {
          throw errorToThrow;
        }
        if (attempts > 1 && method === "GET") throw errorToThrow;
        console.warn(
          `Wasender SDK: Network error on attempt ${attempts} for ${method} ${path}. Retrying if configured...`
        );
        await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
        continue;
      }

      let responseBody: WasenderAPIRawResponse | RegenerateApiKeyResponse | GetSessionStatusResponse;
      try {
        if (httpResponse.status === 204) {
            if (path.includes("/block") || path.includes("/unblock")) {
                 responseBody = { success: true, data: { message: path.includes("/block") ? "Contact blocked" : "Contact unblocked" } } as unknown as WasenderAPIRawResponse;
            } else if (method === "DELETE" && path.startsWith("/whatsapp-sessions/")) {
                 responseBody = { success: true, data: null } as unknown as WasenderAPIRawResponse;
            } else {
                 responseBody = { success: true } as WasenderAPIRawResponse; // Default for 204
            }
        } else {
            // For /status, the response is directly {status: "..."}
            // For /regenerate-key, response is {success: true, api_key: "..."}
            // For others, it's WasenderAPIRawResponse
            if (path === "/status") {
                responseBody = await httpResponse.json() as GetSessionStatusResponse;
            } else if (path.includes("/regenerate-key")) {
                responseBody = await httpResponse.json() as RegenerateApiKeyResponse;
            } else {
                responseBody = (await httpResponse.json()) as WasenderAPIRawResponse;
            }
        }
      } catch (parseError) {
        const errorText = await httpResponse.text().catch(() => "Could not retrieve error text.");
        throw new WasenderAPIError(
          `Failed to parse API response (Status ${httpResponse.status}): ${errorText}`,
          httpResponse.status, undefined, undefined, rateLimitInfo
        );
      }
      
      if (path === '/status' && httpResponse.ok) {
         return {
            response: responseBody as TResponse, 
            rateLimit: rateLimitInfo!, 
        };
      }
      
      if (path.includes('/regenerate-key') && 'api_key' in responseBody && responseBody.success === true) {
        return {
            response: responseBody as TResponse, 
            rateLimit: rateLimitInfo!,
        };
      }

      if (!httpResponse.ok || (responseBody && 'success' in responseBody && typeof responseBody.success === 'boolean' && !responseBody.success)) {
        const apiError = responseBody as WasenderErrorResponse; 
        const errorToThrow = new WasenderAPIError(
          apiError.message || "API request failed with an unspecified error.",
          httpResponse.status,
          apiError.errors,
          apiError.retry_after,
          rateLimitInfo
        );

        if (
          this.retryConfig.enabled &&
          errorToThrow.statusCode === 429 &&
          errorToThrow.retryAfter &&
          errorToThrow.retryAfter > 0 &&
          attempts <= this.retryConfig.maxRetries
        ) {
          console.warn(
            `Wasender SDK: Rate limit (429) on attempt ${attempts} for ${method} ${path}. Retrying after ${errorToThrow.retryAfter}s...`
          );
          await new Promise(resolve => setTimeout(resolve, errorToThrow.retryAfter! * 1000));
          continue; 
        } else {
          throw errorToThrow; 
        }
      }
      
      // This is the general success case for standard responses
      if ('success' in responseBody && responseBody.success === true) {
        return {
          response: responseBody as TResponse,
          rateLimit: rateLimitInfo!,
        };
      }
      
      // Fallback for unexpected response structures that didn't throw an error but aren't recognized success
      throw new WasenderAPIError(
        `Unexpected API response structure from ${method} ${path}. Status: ${httpResponse.status}`,
        httpResponse.status, undefined, undefined, rateLimitInfo
      );
    } // End of while(true)
  } // End of request method

  // General purpose POST (adapted from original post for sending messages)
  private async postInternal<
    TPayload extends Record<string, any> | null, // Generic payload for POST, now allowing null
    TSuccessResponse extends WasenderSuccessResponse // Generic success response
  >(
    path: string,
    payload: TPayload // Payload can be null for block/unblock
  ): Promise<{ response: TSuccessResponse; rateLimit: RateLimitInfo }> {
    // Remove messageType if present, as it was specific to send-message
    const apiPayload = payload ? { ...payload } : null;
    if (apiPayload && 'messageType' in apiPayload) {
      delete apiPayload.messageType;
    }
    return this.request<TSuccessResponse>("POST", path, apiPayload);
  }
  
  // General purpose GET
  private async getInternal<TSuccessResponse extends WasenderSuccessResponse>(
    path: string
  ): Promise<{ response: TSuccessResponse; rateLimit: RateLimitInfo }> {
    return this.request<TSuccessResponse>("GET", path);
  }

  // General purpose PUT
  private async putInternal<
    TPayload extends Record<string, any>,
    TSuccessResponse extends WasenderSuccessResponse
  >(
    path: string,
    payload: TPayload
  ): Promise<{ response: TSuccessResponse; rateLimit: RateLimitInfo }> {
    return this.request<TSuccessResponse>("PUT", path, payload);
  }

  // General purpose DELETE
  private async deleteInternal<TSuccessResponse extends WasenderSuccessResponse>(
    path: string
  ): Promise<{ response: TSuccessResponse; rateLimit: RateLimitInfo }> {
    return this.request<TSuccessResponse>("DELETE", path);
  }

  // ---------- Generic Send Method (modified to use postInternal) ----------
  /**
   * Sends any valid Wasender message payload.
   * @param payload A WasenderMessagePayload object (e.g., TextOnlyMessage, ImageUrlMessage).
   * @returns A promise that resolves to the API response and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async send<T extends WasenderMessagePayload>(payload: T): Promise<WasenderSendResult> {
    // The /send-message path is specific to this method
    const { messageType, ...apiPayload } = payload;
    return this.postInternal<typeof apiPayload, WasenderSuccessResponse>("/send-message", apiPayload) as Promise<WasenderSendResult>;
  }

  // ---------- Specific Endpoint Helpers (Wrappers for the generic send) ----------
  // These now add the `messageType` discriminant before calling the generic send.

  sendText(payload: Omit<TextOnlyMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'text' });
  }

  sendImage(payload: Omit<ImageUrlMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'image' });
  }

  sendVideo(payload: Omit<VideoUrlMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'video' });
  }

  sendDocument(payload: Omit<DocumentUrlMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'document' });
  }

  sendAudio(payload: Omit<AudioUrlMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'audio' });
  }

  sendSticker(payload: Omit<StickerUrlMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'sticker' });
  }

  sendContact(payload: Omit<ContactCardMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'contact' });
  }

  sendLocation(payload: Omit<LocationPinMessage, 'messageType'>): Promise<WasenderSendResult> {
    return this.send({ ...payload, messageType: 'location' });
  }

  // ---------- Contact Management Methods ----------

  /**
   * Retrieves a list of all contacts synced with the WhatsApp session.
   * @returns A promise that resolves to the list of contacts and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getContacts(): Promise<GetAllContactsResult> {
    return this.getInternal<GetAllContactsResponse>("/contacts");
  }

  /**
   * Retrieves detailed information for a specific contact.
   * @param contactPhoneNumber The JID (Jabber ID) of the contact in E.164 format (e.g., 1234567890).
   * @returns A promise that resolves to the contact information and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getContactInfo(contactPhoneNumber: string): Promise<GetContactInfoResult> {
    if (!contactPhoneNumber) {
      throw new WasenderAPIError("Contact phone number (JID) is required.", 400);
    }
    return this.getInternal<GetContactInfoResponse>(`/contacts/${contactPhoneNumber}`);
  }

  /**
   * Retrieves the URL of the profile picture for a specific contact.
   * @param contactPhoneNumber The JID (Jabber ID) of the contact in E.164 format (e.g., 1234567890).
   * @returns A promise that resolves to the profile picture URL and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getContactProfilePicture(contactPhoneNumber: string): Promise<GetContactProfilePictureResult> {
    if (!contactPhoneNumber) {
      throw new WasenderAPIError("Contact phone number (JID) is required.", 400);
    }
    return this.getInternal<GetContactProfilePictureResponse>(`/contacts/${contactPhoneNumber}/picture`);
  }

  /**
   * Blocks a specific contact.
   * @param contactPhoneNumber The JID (Jabber ID) of the contact in E.164 format (e.g., 1234567890).
   * @returns A promise that resolves to the action status and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async blockContact(contactPhoneNumber: string): Promise<ContactActionResult> {
    if (!contactPhoneNumber) {
      throw new WasenderAPIError("Contact phone number (JID) is required.", 400);
    }
    // POST request, potentially with no body or an empty JSON body
    return this.postInternal<null, ContactActionResponse>(`/contacts/${contactPhoneNumber}/block`, null);
  }

  /**
   * Unblocks a specific contact.
   * @param contactPhoneNumber The JID (Jabber ID) of the contact in E.164 format (e.g., 1234567890).
   * @returns A promise that resolves to the action status and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async unblockContact(contactPhoneNumber: string): Promise<ContactActionResult> {
    if (!contactPhoneNumber) {
      throw new WasenderAPIError("Contact phone number (JID) is required.", 400);
    }
    // POST request, potentially with no body or an empty JSON body
    return this.postInternal<null, ContactActionResponse>(`/contacts/${contactPhoneNumber}/unblock`, null);
  }

  // ---------- Group Management Methods ----------

  /**
   * Retrieves a list of all WhatsApp groups the connected account is a member of.
   * @returns A promise that resolves to the list of groups and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getGroups(): Promise<GetAllGroupsResult> {
    return this.getInternal<GetAllGroupsResponse>("/groups");
  }

  /**
   * Retrieves metadata for a specific group.
   * @param groupJid The JID of the group (e.g., '123456789-987654321@g.us').
   * @returns A promise that resolves to the group metadata and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getGroupMetadata(groupJid: string): Promise<GetGroupMetadataResult> {
    if (!groupJid) {
      throw new WasenderAPIError("Group JID is required.", 400);
    }
    return this.getInternal<GetGroupMetadataResponse>(`/groups/${groupJid}/metadata`);
  }

  /**
   * Retrieves a list of participants for a specific group.
   * @param groupJid The JID of the group.
   * @returns A promise that resolves to the list of group participants and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getGroupParticipants(groupJid: string): Promise<GetGroupParticipantsResult> {
    if (!groupJid) {
      throw new WasenderAPIError("Group JID is required.", 400);
    }
    return this.getInternal<GetGroupParticipantsResponse>(`/groups/${groupJid}/participants`);
  }

  /**
   * Adds participants to a specific group. Requires admin privileges in the group.
   * @param groupJid The JID of the group.
   * @param participants An array of participant JIDs (E.164 format phone numbers) to add.
   * @returns A promise that resolves to the action status for each participant and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async addGroupParticipants(groupJid: string, participants: string[]): Promise<ModifyGroupParticipantsResult> {
    if (!groupJid) {
      throw new WasenderAPIError("Group JID is required.", 400);
    }
    if (!participants || participants.length === 0) {
      throw new WasenderAPIError("Participants array cannot be null or empty.", 400);
    }
    const payload: ModifyGroupParticipantsPayload = { participants };
    return this.postInternal<ModifyGroupParticipantsPayload, ModifyGroupParticipantsResponse>(
      `/groups/${groupJid}/participants/add`,
      payload
    );
  }

  /**
   * Removes participants from a specific group. Requires admin privileges in the group.
   * @param groupJid The JID of the group.
   * @param participants An array of participant JIDs (E.164 format phone numbers) to remove.
   * @returns A promise that resolves to the action status for each participant and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async removeGroupParticipants(groupJid: string, participants: string[]): Promise<ModifyGroupParticipantsResult> {
    if (!groupJid) {
      throw new WasenderAPIError("Group JID is required.", 400);
    }
    if (!participants || participants.length === 0) {
      throw new WasenderAPIError("Participants array cannot be null or empty.", 400);
    }
    const payload: ModifyGroupParticipantsPayload = { participants };
    return this.postInternal<ModifyGroupParticipantsPayload, ModifyGroupParticipantsResponse>(
      `/groups/${groupJid}/participants/remove`,
      payload
    );
  }

  /**
   * Updates settings for a specific group.
   * @param groupJid The JID of the group.
   * @param settings An object containing the settings to update (e.g., subject, description, announce, restrict).
   * @returns A promise that resolves to the updated group settings information and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async updateGroupSettings(groupJid: string, settings: UpdateGroupSettingsPayload): Promise<UpdateGroupSettingsResult> {
    if (!groupJid) {
      throw new WasenderAPIError("Group JID is required.", 400);
    }
    if (Object.keys(settings).length === 0) {
        throw new WasenderAPIError("Settings object cannot be empty.", 400);
    }
    return this.putInternal<UpdateGroupSettingsPayload, UpdateGroupSettingsResponse>(
      `/groups/${groupJid}/settings`,
      settings
    );
  }

  // ---------- Session Management Methods ----------

  /**
   * Retrieves a list of all WhatsApp sessions available to the authenticated user.
   * @returns A promise that resolves to the list of WhatsApp sessions and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getAllWhatsAppSessions(): Promise<GetAllWhatsAppSessionsResult> {
    return this.getInternal<GetAllWhatsAppSessionsResponse>("/whatsapp-sessions");
  }

  /**
   * Creates a new WhatsApp session.
   * @param payload Details for the new session.
   * @returns A promise that resolves to the created session information and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async createWhatsAppSession(payload: CreateWhatsAppSessionPayload): Promise<CreateWhatsAppSessionResult> {
    return this.postInternal<CreateWhatsAppSessionPayload, CreateWhatsAppSessionResponse>("/whatsapp-sessions", payload);
  }

  /**
   * Retrieves details for a specific WhatsApp session.
   * @param sessionId ID of the WhatsApp session.
   * @returns A promise that resolves to the session details and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getWhatsAppSessionDetails(sessionId: number): Promise<GetWhatsAppSessionDetailsResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    return this.getInternal<GetWhatsAppSessionDetailsResponse>(`/whatsapp-sessions/${sessionId}`);
  }

  /**
   * Updates details for a specific WhatsApp session.
   * @param sessionId ID of the WhatsApp session.
   * @param payload Fields to update.
   * @returns A promise that resolves to the updated session details and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async updateWhatsAppSession(sessionId: number, payload: UpdateWhatsAppSessionPayload): Promise<UpdateWhatsAppSessionResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    if (Object.keys(payload).length === 0) throw new WasenderAPIError("Update payload cannot be empty.", 400);
    return this.putInternal<UpdateWhatsAppSessionPayload, UpdateWhatsAppSessionResponse>(`/whatsapp-sessions/${sessionId}`, payload);
  }

  /**
   * Deletes a specific WhatsApp session.
   * @param sessionId ID of the WhatsApp session.
   * @returns A promise that resolves to the deletion confirmation and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async deleteWhatsAppSession(sessionId: number): Promise<DeleteWhatsAppSessionResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    return this.deleteInternal<DeleteWhatsAppSessionResponse>(`/whatsapp-sessions/${sessionId}`);
  }

  /**
   * Initiates the connection process for a WhatsApp session.
   * @param sessionId ID of the WhatsApp session.
   * @param qrAsImage Optional. If true, requests the QR code as an image in the response.
   * @returns A promise that resolves to the connection status (e.g., QR code) and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async connectWhatsAppSession(sessionId: number, qrAsImage?: boolean): Promise<ConnectSessionResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    const payload: ConnectSessionPayload | null = qrAsImage !== undefined ? { qr_as_image: qrAsImage } : null;
    return this.postInternal<ConnectSessionPayload | null, ConnectSessionResponse>(
        `/whatsapp-sessions/${sessionId}/connect`,
        payload
    );
  }

  /**
   * Retrieves the QR code for connecting a WhatsApp session.
   * @param sessionId ID of the WhatsApp session.
   * @returns A promise that resolves to the QR code data and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async getWhatsAppSessionQRCode(sessionId: number): Promise<GetQRCodeResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    return this.getInternal<GetQRCodeResponse>(`/whatsapp-sessions/${sessionId}/qrcode`);
  }

  /**
   * Disconnects an active WhatsApp session.
   * @param sessionId ID of the WhatsApp session.
   * @returns A promise that resolves to the disconnection status and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async disconnectWhatsAppSession(sessionId: number): Promise<DisconnectSessionResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    return this.postInternal<null, DisconnectSessionResponse>(`/whatsapp-sessions/${sessionId}/disconnect`, null);
  }

  /**
   * Regenerates the API key for a specific WhatsApp session.
   * Note: The response structure for this endpoint is unique.
   * @param sessionId ID of the WhatsApp session.
   * @returns A promise that resolves to the new API key and rate limit information.
   * @throws WasenderAPIError if the request fails.
   */
  public async regenerateApiKey(sessionId: number): Promise<RegenerateApiKeyResult> {
    if (!sessionId) throw new WasenderAPIError("Session ID is required.", 400);
    // This request method will need special handling for the response type if it deviates significantly
    // from WasenderSuccessResponse, especially in error scenarios if they also don\'t fit WasenderErrorResponse.
    // For now, assuming success fits RegenerateApiKeyResponse and errors fit WasenderAPIError.
    return this.request<RegenerateApiKeyResponse>("POST", `/whatsapp-sessions/${sessionId}/regenerate-key`, {});
  }

  /**
   * Retrieves the current status of the WhatsApp session associated with the API key.
   * Note: The response structure for this endpoint is unique and does not include a session ID.
   * @returns A promise that resolves to the session status. Rate limiting may or may not apply as per API docs.
   * @throws WasenderAPIError if the request fails.
   */
  public async getSessionStatus(): Promise<GetSessionStatusResult> {
    // This is a special case. The response isn\'t wrapped in `data` and `success` fields.
    // The generic `request` method will need to be aware of this, or we use fetchImpl directly.
    // For now, we will assume `request` can handle it based on path or a new parameter.
    // The `GetSessionStatusResponse` is `{ status: "..." }`.
    // If rate limits are returned, `GetSessionStatusResult` includes `RateLimitInfo`.
    const result = await this.request<GetSessionStatusResponse>("GET", "/status");
    return result as GetSessionStatusResult; // Casting, assuming rateLimitInfo is part of the raw result from request
  }

  // ---------- Webhook Handling ----------
  /**
   * Verifies and parses an incoming Wasender webhook event.
   * @param request An object that adapts your HTTP framework's request, providing methods to get headers and the raw body.
   * @returns A promise that resolves to the parsed WasenderWebhookEvent.
   * @throws WasenderAPIError if the webhook secret is not configured in the SDK, if the signature is invalid, or if the body cannot be parsed.
   */
  public async handleWebhookEvent(request: WebhookRequestAdapter): Promise<WasenderWebhookEvent> {
    if (!this.configuredWebhookSecret) {
      throw new WasenderAPIError("Webhook secret is not configured in the Wasender SDK instance. Cannot verify signature.");
    }

    const signature = request.getHeader(WEBHOOK_SIGNATURE_HEADER);
    if (!verifyWasenderWebhookSignature(signature, this.configuredWebhookSecret)) {
      throw new WasenderAPIError("Invalid webhook signature.", 401); // Using 401 for unauthorized
    }

    let rawBody: string;
    try {
      const bodyPromiseOrString = request.getRawBody();
      rawBody = typeof bodyPromiseOrString === 'string' ? bodyPromiseOrString : await bodyPromiseOrString;
    } catch (err) {
        const message = err instanceof Error ? err.message : "Unknown error";
      throw new WasenderAPIError(`Failed to get raw body for webhook: ${message}`);
    }

    try {
      const parsedEvent = JSON.parse(rawBody) as WasenderWebhookEvent;
      return parsedEvent;
    } catch (err) {
        const message = err instanceof Error ? err.message : "Unknown error";
      throw new WasenderAPIError(`Failed to parse webhook JSON body: ${message}`);
    }
  }
}

// ---------- Example Helper Factory ----------
export const createWasender = (
    apiKey: string, 
    baseUrl?: string, 
    fetchImplementation?: FetchImplementation,
    retryOptions?: RetryConfig,
    webhookSecret?: string 
): Wasender => new Wasender(apiKey, baseUrl, fetchImplementation, retryOptions, webhookSecret);
